#!/usr/bin/python

# usage:
#   python-console <port> <magic> [<working-dir>]

import cjson
import codeop
import md5
import os
import Queue
import signal
import socket
import sys
import traceback
from threading import Thread
from functools import partial

import common.chat

class Interrupt(Exception):
    def __init__(self):
        Exception.__init__(self, "Interrupted!")

class ExpiryTimer(object):
    def __init__(self, idle):
        self.idle = idle
        signal.signal(signal.SIGALRM, partial(self.timeout))

    def ping(self):
        signal.alarm(self.idle)

    def start(self, time):
        signal.alarm(time)

    def stop(self):
        self.ping()

    def timeout(self, signum, frame):
        sys.exit(1)
        
class StdinFromWeb(object):
    def __init__(self, cmdQ, lineQ):
        self.cmdQ = cmdQ
        self.lineQ = lineQ

    def readline(self):
        self.cmdQ.put({"input":None})
        expiry.ping()
        ln = self.lineQ.get()
        if 'chat' in ln:
            return ln['chat']
        if 'interrupt' in ln:
            raise Interrupt()
        if 'terminate' in ln:
            sys.exit(0)
            

class StdoutToWeb(object):
    def __init__(self, cmdQ, lineQ):
        self.cmdQ = cmdQ
        self.lineQ = lineQ
        self.remainder = ''

    def _trim_incomplete_final(self, stuff):
        '''Trim an incomplete UTF-8 character from the end of a string.
           Returns (trimmed_string, count_of_trimmed_bytes).
        '''
        tokill = incomplete_utf8_sequence(stuff)
        if tokill == 0:
            return (stuff, tokill)
        else:
            return (stuff[:-tokill], tokill)

    def write(self, stuff):
        # print will only give a non-file a unicode or str. There's no way
        # to convince it to encode unicodes, so we have to do it ourselves.
        # Yay for file special-cases (fileobject.c, PyFile_WriteObject).
        # If somebody wants to write some other object to here, they do it
        # at their own peril.
        if isinstance(stuff, unicode):
            stuff = stuff.encode('utf-8')
        self.remainder = self.remainder + stuff

        # if there's less than 128 bytes, buffer
        if len(self.remainder) < 128:
            return

        # if there's lots, then send it in 1/2K blocks
        while len(self.remainder) > 512:
            # We send things as Unicode inside JSON, so we must only send
            # complete UTF-8 characters.
            (blk, count) = self._trim_incomplete_final(self.remainder[:512])
            self.cmdQ.put({"output":blk.decode('utf-8', 'replace')})
            expiry.ping()
            ln = self.lineQ.get()
            self.remainder = self.remainder[512 - count:]

        # Finally, split the remainder up into lines, and ship all the
        # completed lines off to the server.
        lines = self.remainder.split("\n")
        self.remainder = lines[-1]
        del lines[-1]

        if len(lines) > 0:
            lines.append('')
            text = "\n".join(lines)
            self.cmdQ.put({"output":text.decode('utf-8', 'replace')})
            expiry.ping()
            ln = self.lineQ.get()
            if 'interrupt' in ln:
                raise Interrupt()

    def flush(self):
        if len(self.remainder) > 0:
            (out, count) = self._trim_incomplete_final(self.remainder)
            self.cmdQ.put({"output":out.decode('utf-8', 'replace')})
            expiry.ping()
            ln = self.lineQ.get()
            # Leave incomplete characters in the buffer.
            # Yes, this does mean that an incomplete character will be left
            # off the end, but we discussed this and it was deemed best.
            self.remainder = self.remainder[len(self.remainder)-count:]
            if 'interrupt' in ln:
                raise Interrupt()

class WebIO(object):
    """Provides a file like interface to the Web front end of the console.
    You may print text to the console using write(), flush any buffered output 
    using flush(), or request text from the console using readline()"""
    
    def __init__(self, cmdQ, lineQ):
        self.cmdQ = cmdQ
        self.lineQ = lineQ
        self.stdin = StdinFromWeb(self.cmdQ, self.lineQ)
        self.stdout = StdoutToWeb(self.cmdQ, self.lineQ)

    def write(self, stuff):
        self.stdout.write(stuff)

    def flush(self):
        self.stdout.flush()

    def readline(self):
        self.stdout.flush()
        return self.stdin.readline()

class PythonRunner(Thread):
    def __init__(self, cmdQ, lineQ):
        self.cmdQ = cmdQ
        self.lineQ = lineQ
        self.webio = WebIO(self.cmdQ, self.lineQ)
        Thread.__init__(self)

    def execCmd(self, cmd):
        try:
            sys.stdin = self.webio
            sys.stdout = self.webio
            sys.stderr = self.webio
            # We don't expect a return value - 'single' symbol prints it.
            eval(cmd, self.globs)
            self.webio.flush()
            self.cmdQ.put({"okay": None})
            self.curr_cmd = ''
        except:
            tb = format_exc_start(start=1)
            self.webio.flush()
            self.cmdQ.put({"exc": ''.join(tb).decode('utf-8', 'replace')})
            self.curr_cmd = ''

    def run(self):
        self.globs = {}
        self.globs['__builtins__'] = globals()['__builtins__']
        self.curr_cmd = ''

        while True:
            ln = self.lineQ.get()
            if 'chat' in ln:
                if self.curr_cmd == '':
                    self.curr_cmd = ln['chat']
                else:
                    self.curr_cmd = self.curr_cmd + '\n' + ln['chat']
                try:
                    cmd = codeop.compile_command(self.curr_cmd, '<web session>')
                    if cmd is None:
                        # The command was incomplete,
                        # so send back a None, so the
                        # client can print a '...'
                        self.cmdQ.put({"more":None})
                    else:
                        self.execCmd(cmd)
                except:
                    tb = format_exc_start(start=3)
                    self.cmdQ.put({"exc": ''.join(tb).decode('utf-8', 'replace')})
                    self.webio.flush()
                    self.curr_cmd = ''
            if 'block' in ln:
                # throw away a partial command.
                try:
                    cmd = compile(ln['block'], "<web session>", 'exec');
                    self.execCmd(cmd)
                except:
                    tb = format_exc_start(start=1)
                    self.webio.flush()
                    self.cmdQ.put({"exc": ''.join(tb).decode('utf-8', 'replace')})
                    self.curr_cmd = ''

def daemonize():
    if os.fork():   # launch child and...
        os._exit(0) # kill off parent
    os.setsid()
    if os.fork():   # launch child and...
        os._exit(0) # kill off parent again.
    os.umask(077)

# The global 'magic' is the secret that the client and server share
# which is used to create and md5 digest to authenticate requests.
# It is assigned a real value at startup.
magic = ''

cmdQ = Queue.Queue()
lineQ = Queue.Queue()
interpThread = PythonRunner(cmdQ, lineQ)

# Default expiry time of 15 minutes
expiry = ExpiryTimer(15 * 60)

def initializer():
    interpThread.setDaemon(True)
    interpThread.start()
    expiry.ping()

def dispatch_msg(msg):
    expiry.ping()
    lineQ.put({msg['cmd']:msg['text']})
    return cmdQ.get()

def format_exc_start(start=0):
    etype, value, tb = sys.exc_info()
    tbbits = traceback.extract_tb(tb)[start:]
    list = ['Traceback (most recent call last):\n']
    list = list + traceback.format_list(tbbits)
    list = list + traceback.format_exception_only(etype, value)
    return ''.join(list)

def incomplete_utf8_sequence(byteseq):
    """
    str -> int
    Given a UTF-8-encoded byte sequence (str), returns the number of bytes at
    the end of the string which comprise an incomplete UTF-8 character
    sequence.

    If the string is empty or ends with a complete character OR INVALID
    sequence, returns 0.
    Otherwise, returns 1-3 indicating the number of bytes in the final
    incomplete (but valid) character sequence.

    Does not check any bytes before the final sequence for correctness.

    >>> incomplete_utf8_sequence("")
    0
    >>> incomplete_utf8_sequence("xy")
    0
    >>> incomplete_utf8_sequence("xy\xc3\xbc")
    0
    >>> incomplete_utf8_sequence("\xc3")
    1
    >>> incomplete_utf8_sequence("\xbc\xc3")
    1
    >>> incomplete_utf8_sequence("xy\xbc\xc3")
    1
    >>> incomplete_utf8_sequence("xy\xe0\xa0")
    2
    >>> incomplete_utf8_sequence("xy\xf4")
    1
    >>> incomplete_utf8_sequence("xy\xf4\x8f")
    2
    >>> incomplete_utf8_sequence("xy\xf4\x8f\xa0")
    3
    """
    count = 0
    expect = None
    for b in byteseq[::-1]:
        b = ord(b)
        count += 1
        if b & 0x80 == 0x0:
            # 0xxxxxxx (single-byte character)
            expect = 1
            break
        elif b & 0xc0 == 0x80:
            # 10xxxxxx (subsequent byte)
            pass
        elif b & 0xe0 == 0xc0:
            # 110xxxxx (start of 2-byte sequence)
            expect = 2
            break
        elif b & 0xf0 == 0xe0:
            # 1110xxxx (start of 3-byte sequence)
            expect = 3
            break
        elif b & 0xf8 == 0xf0:
            # 11110xxx (start of 4-byte sequence)
            expect = 4
            break
        else:
            # Invalid byte
            return 0

        if count >= 4:
            # Seen too many "subsequent bytes", invalid
            return 0

    if expect is None:
        # We never saw a "first byte", invalid
        return 0

    # We now know expect and count
    if count >= expect:
        # Complete, or we saw an invalid sequence
        return 0
    elif count < expect:
        # Incomplete
        return count

if __name__ == "__main__":
    port = int(sys.argv[1])
    magic = sys.argv[2]
    if len(sys.argv) >= 4:
        # working_dir
        os.chdir(sys.argv[3])
        # Make python's search path follow the cwd
        sys.path[0] = ''
        os.environ['HOME'] = sys.argv[3]

    common.chat.start_server(port, magic, True, dispatch_msg, initializer)
