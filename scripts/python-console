#!/usr/bin/python

# usage:
#   python-console <port> <magic> [<working-dir>]

import cjson
import codeop
import md5
import os
import Queue
import signal
import socket
import sys
from threading import Thread
from functools import partial

import common.chat

class Interrupt(Exception):
    def __init__(self):
        Exception.__init__(self, "Interrupted!")

class ExpiryTimer(object):
    def __init__(self, idle):
        self.idle = idle
        signal.signal(signal.SIGALRM, partial(self.timeout))

    def ping(self):
        signal.alarm(self.idle)

    def start(self, time):
        signal.alarm(time)

    def stop(self):
        self.ping()

    def timeout(self, signum, frame):
        sys.exit(1)
        
class StdinFromWeb(object):
    def __init__(self, cmdQ, lineQ):
        self.cmdQ = cmdQ
        self.lineQ = lineQ

    def readline(self):
        self.cmdQ.put({"input":None})
        expiry.ping()
        ln = self.lineQ.get()
        if 'chat' in ln:
            return ln['chat']
        if 'interrupt' in ln:
            raise Interrupt()

class StdoutToWeb(object):
    def __init__(self, cmdQ, lineQ):
        self.cmdQ = cmdQ
        self.lineQ = lineQ
        self.remainder = ''

    def write(self, stuff):
        self.remainder = self.remainder + stuff

        # if there's less than 128 bytes, buffer
        if len(self.remainder) < 128:
            return

        # if there's lots, then send it in 1/2K blocks
        while len(self.remainder) > 512:
            blk = self.remainder[0:512]
            self.cmdQ.put({"output":blk})
            expiry.ping()
            ln = self.lineQ.get()
            self.remainder = self.remainder[512:]

        # Finally, split the remainder up into lines, and ship all the
        # completed lines off to the server.
        lines = self.remainder.split("\n")
        self.remainder = lines[-1]
        del lines[-1]

        if len(lines) > 0:
            lines.append('')
            text = "\n".join(lines)
            self.cmdQ.put({"output":text})
            expiry.ping()
            ln = self.lineQ.get()
            if 'interrupt' in ln:
                raise Interrupt()

    def flush(self):
        if len(self.remainder) > 0:
            self.cmdQ.put({"output":self.remainder})
            expiry.ping()
            ln = self.lineQ.get()
            self.remainder = ''
            if 'interrupt' in ln:
                raise Interrupt()

class PythonRunner(Thread):
    def __init__(self, cmdQ, lineQ):
        self.cmdQ = cmdQ
        self.lineQ = lineQ
        self.stdout = StdoutToWeb(self.cmdQ, self.lineQ)
        Thread.__init__(self)

    def execCmd(self, cmd):
        try:
            sys.stdin = StdinFromWeb(self.cmdQ, self.lineQ)
            sys.stdout = self.stdout
            sys.stderr = self.stdout
            res = eval(cmd, self.globs)
            self.stdout.flush()
            self.cmdQ.put({"okay":res})
            self.curr_cmd = ''
        except Exception, exc:
            self.stdout.flush()
            exc_classname = exc.__class__.__name__
            self.cmdQ.put({"exc": exc_classname + ": " + str(exc)})
            self.curr_cmd = ''

    def run(self):
        self.globs = {}
        self.globs['__builtins__'] = globals()['__builtins__']
        self.curr_cmd = ''
        compiler = codeop.CommandCompiler()

        while True:
            ln = self.lineQ.get()
            if 'chat' in ln:
                if self.curr_cmd == '':
                    self.curr_cmd = ln['chat']
                else:
                    self.curr_cmd = self.curr_cmd + '\n' + ln['chat']
                try:
                    cmd = compiler(self.curr_cmd)
                    if cmd is None:
                        # The command was incomplete,
                        # so send back a None, so the
                        # client can print a '...'
                        self.cmdQ.put({"more":None})
                    else:
                        self.execCmd(cmd)
                except Exception, exc:
                    self.stdout.flush()
                    self.cmdQ.put({"exc":str(exc)})
                    self.curr_cmd = ''
            if 'block' in ln:
                # throw away a partial command.
                try:
                    cmd = compile(ln['block'], "<web session>", 'exec');
                    self.execCmd(cmd)
                except Exception, exc:
                    self.stdout.flush()
                    self.cmdQ.put({"exc":str(exc)})
                    self.curr_cmd = ''

def daemonize():
    if os.fork():   # launch child and...
        os._exit(0) # kill off parent
    os.setsid()
    if os.fork():   # launch child and...
        os._exit(0) # kill off parent again.
    os.umask(077)

# The global 'magic' is the secret that the client and server share
# which is used to create and md5 digest to authenticate requests.
# It is assigned a real value at startup.
magic = ''

cmdQ = Queue.Queue()
lineQ = Queue.Queue()
interpThread = PythonRunner(cmdQ, lineQ)

# Default expiry time of 15 minutes
expiry = ExpiryTimer(15 * 60)

def initializer():
    interpThread.setDaemon(True)
    interpThread.start()
    expiry.ping()

def dispatch_msg(msg):
    expiry.ping()
    lineQ.put({msg['cmd']:msg['text']})
    return cmdQ.get()

if __name__ == "__main__":
    port = int(sys.argv[1])
    magic = sys.argv[2]
    if len(sys.argv) >= 4:
        # working_dir
        os.chdir(sys.argv[3])
        os.environ['HOME'] = sys.argv[3]

    common.chat.start_server(port, magic, True, dispatch_msg, initializer)
