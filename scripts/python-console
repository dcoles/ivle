#!/usr/bin/python

# usage:
#   python-console <port> <magic>

import cjson
import codeop
import cStringIO
import md5
import os
import Queue
import signal
import socket
import sys
from threading import Thread

import common.chat

class StdinFromWeb(object):
    def __init__(self, cmdQ, lineQ):
        self.cmdQ = cmdQ
        self.lineQ = lineQ

    def readline(self):
        # stop the clock!
        signal.alarm(0)
        self.cmdQ.put({"input":None})
        ln = self.lineQ.get()
        if 'chat' in ln:
            # restart the clock:
            # Some of our 5 seconds may have elapsed, but never mind.
            signal.alarm(5)
            return ln['chat']

class PythonRunner(Thread):
    def __init__(self, cmdQ, lineQ):
        self.cmdQ = cmdQ
        self.lineQ = lineQ
        self.out = cStringIO.StringIO()
        Thread.__init__(self)

    def execCmd(self, cmd):
        try:
            sys.stdin = StdinFromWeb(self.cmdQ, self.lineQ)
            sys.stdout = self.out
            sys.stderr = self.out
            signal.alarm(5)
            res = eval(cmd, self.globs, self.locls)
            signal.alarm(0)
            self.cmdQ.put({"okay":(self.out.getvalue(),res)})
            self.curr_cmd = ''
            self.out = cStringIO.StringIO()
        except Exception, exc:
            signal.alarm(0)
            self.cmdQ.put({"exc":(self.out.getvalue(),str(exc))})
            self.curr_cmd = ''
            self.out = cStringIO.StringIO()

    def run(self):
        self.init_state()
        compiler = codeop.CommandCompiler()

        while True:
            ln = self.lineQ.get()
            if 'chat' in ln:
                if self.curr_cmd == '':
                    self.curr_cmd = ln['chat']
                else:
                    self.curr_cmd = self.curr_cmd + '\n' + ln['chat']
                try:
                    cmd = compiler(self.curr_cmd)
                    if cmd is None:
                        # The command was incomplete,
                        # so send back a None, so the
                        # client can print a '...'
                        self.cmdQ.put({"more":None})
                    else:
                        self.execCmd(cmd)
                except Exception, exc:
                    signal.alarm(0)
                    self.cmdQ.put({"exc":(self.out.getvalue(),str(exc))})
                    self.curr_cmd = ''
                    self.out = cStringIO.StringIO()
            if 'block' in ln:
                # throw away a partial command.
                try:
                    cmd = compile(ln['block'], "<web session>", 'exec');
                    self.execCmd(cmd)
                except Exception, exc:
                    signal.alarm(0)
                    self.cmdQ.put({"exc":(self.out.getvalue(),str(exc))})
                    self.curr_cmd = ''
                    self.out = cStringIO.StringIO()

    def init_state(self):
        self.globs = {}
        self.globs['__builtins__'] = globals()['__builtins__']
        self.locls = {}
        self.curr_cmd = ''

def daemonize():
    if os.fork():   # launch child and...
        os._exit(0) # kill off parent
    os.setsid()
    if os.fork():   # launch child and...
        os._exit(0) # kill off parent again.
    os.umask(077)

# The global 'magic' is the secret that the client and server share
# which is used to create and md5 digest to authenticate requests.
# It is assigned a real value at startup.
magic = ''

cmdQ = Queue.Queue()
lineQ = Queue.Queue()
interpThread = PythonRunner(cmdQ, lineQ)

def initializer():
    interpThread.setDaemon(True)
    interpThread.start()

def dispatch_msg(msg):
    lineQ.put({msg['cmd']:msg['text']})
    return cmdQ.get()

if __name__ == "__main__":
    port = int(sys.argv[1])
    magic = sys.argv[2]

    common.chat.start_server(port, magic, True, dispatch_msg, initializer)
