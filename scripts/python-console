#!/usr/bin/python

# usage:
#   python-console <port> <magic>

import cjson
import codeop
import md5
import os
import Queue
import signal
import socket
import sys
from threading import Thread
from functools import partial

import common.chat

class Interrupt(Exception):
    pass

class ExpiryTimer(object):
    def __init__(self, idle):
        self.idle = idle
        signal.signal(signal.SIGALRM, partial(self.timeout))

    def ping(self):
        signal.alarm(self.idle)

    def start(self, time):
        signal.alarm(time)

    def stop(self):
        self.ping()

    def timeout(self, signum, frame):
        sys.exit(1)
        
class StdinFromWeb(object):
    def __init__(self, cmdQ, lineQ):
        self.cmdQ = cmdQ
        self.lineQ = lineQ

    def readline(self):
        self.cmdQ.put({"input":None})
        expiry.ping()
        ln = self.lineQ.get()
        if 'chat' in ln:
            return ln['chat']

class StdoutToWeb(object):
    def __init__(self, cmdQ, lineQ):
        self.cmdQ = cmdQ
        self.lineQ = lineQ
        self.remainder = ''

    def write(self, stuff):
        # Split the content up into lines, and ship all the completed
        # lines off to the server.
        lines = stuff.split("\n")
        lines[0] = self.remainder + lines[0]
        self.remainder = lines[-1]
        del lines[-1]

        if len(lines) > 0:
            self.cmdQ.put({"output":lines})
            expiry.ping()
            ln = self.lineQ.get()
            if 'interrupt' in ln:
                raise Interrupt()

    def flush(self):
        res = self.remainder
        self.remainder = ''
        return res

class PythonRunner(Thread):
    def __init__(self, cmdQ, lineQ):
        self.cmdQ = cmdQ
        self.lineQ = lineQ
        self.out = None
        Thread.__init__(self)

    def execCmd(self, cmd):
        try:
            sys.stdin = StdinFromWeb(self.cmdQ, self.lineQ)
            self.out = StdoutToWeb(self.cmdQ, self.lineQ)
            sys.stdout = self.out
            sys.stderr = self.out
            res = eval(cmd, self.globs, self.locls)
            self.cmdQ.put({"okay":(self.out.flush(),res)})
            self.curr_cmd = ''
        except Exception, exc:
            self.cmdQ.put({"exc":(self.out.flush(),str(exc))})
            self.curr_cmd = ''

    def run(self):
        self.globs = {}
        self.globs['__builtins__'] = globals()['__builtins__']
        self.locls = {}
        self.curr_cmd = ''
        compiler = codeop.CommandCompiler()

        while True:
            ln = self.lineQ.get()
            if 'chat' in ln:
                if self.curr_cmd == '':
                    self.curr_cmd = ln['chat']
                else:
                    self.curr_cmd = self.curr_cmd + '\n' + ln['chat']
                try:
                    cmd = compiler(self.curr_cmd)
                    if cmd is None:
                        # The command was incomplete,
                        # so send back a None, so the
                        # client can print a '...'
                        self.cmdQ.put({"more":None})
                    else:
                        self.execCmd(cmd)
                except Exception, exc:
                    self.cmdQ.put({"exc":(self.out.flush(),str(exc))})
                    self.curr_cmd = ''
            if 'block' in ln:
                # throw away a partial command.
                try:
                    cmd = compile(ln['block'], "<web session>", 'exec');
                    self.execCmd(cmd)
                except Exception, exc:
                    self.cmdQ.put({"exc":(self.out.flush(),str(exc))})
                    self.curr_cmd = ''

def daemonize():
    if os.fork():   # launch child and...
        os._exit(0) # kill off parent
    os.setsid()
    if os.fork():   # launch child and...
        os._exit(0) # kill off parent again.
    os.umask(077)

# The global 'magic' is the secret that the client and server share
# which is used to create and md5 digest to authenticate requests.
# It is assigned a real value at startup.
magic = ''

cmdQ = Queue.Queue()
lineQ = Queue.Queue()
interpThread = PythonRunner(cmdQ, lineQ)

# Default expiry time of 15 minutes
expiry = ExpiryTimer(15 * 60)

def initializer():
    interpThread.setDaemon(True)
    interpThread.start()
    expiry.ping()

def dispatch_msg(msg):
    expiry.ping()
    lineQ.put({msg['cmd']:msg['text']})
    return cmdQ.get()

if __name__ == "__main__":
    port = int(sys.argv[1])
    magic = sys.argv[2]

    common.chat.start_server(port, magic, True, dispatch_msg, initializer)
