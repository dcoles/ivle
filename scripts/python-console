#!/usr/bin/python

# usage:
#   python-console <port> <magic> [<working-dir>]

import cjson
import codeop
import cPickle
import cStringIO
import md5
import os
import Queue
import signal
import socket
import sys
import traceback
from threading import Thread

import common.chat
import common.util

# This version must be supported by both the local and remote code
PICKLEVERSION = 0

class Interrupt(Exception):
    def __init__(self):
        Exception.__init__(self, "Interrupted!")

class ExpiryTimer(object):
    def __init__(self, idle):
        self.idle = idle
        signal.signal(signal.SIGALRM, self.timeout)

    def ping(self):
        signal.alarm(self.idle)

    def start(self, time):
        signal.alarm(time)

    def stop(self):
        self.ping()

    def timeout(self, signum, frame):
        sys.exit(1)

class StdinFromWeb(object):
    def __init__(self, cmdQ, lineQ):
        self.cmdQ = cmdQ
        self.lineQ = lineQ

    def readline(self):
        self.cmdQ.put({"input":None})
        expiry.ping()
        ln = self.lineQ.get()
        if 'chat' in ln:
            return ln['chat']
        if 'interrupt' in ln:
            raise Interrupt()

class StdoutToWeb(object):
    def __init__(self, cmdQ, lineQ):
        self.cmdQ = cmdQ
        self.lineQ = lineQ
        self.remainder = ''

    def _trim_incomplete_final(self, stuff):
        '''Trim an incomplete UTF-8 character from the end of a string.
           Returns (trimmed_string, count_of_trimmed_bytes).
        '''
        tokill = incomplete_utf8_sequence(stuff)
        if tokill == 0:
            return (stuff, tokill)
        else:
            return (stuff[:-tokill], tokill)

    def write(self, stuff):
        # print will only give a non-file a unicode or str. There's no way
        # to convince it to encode unicodes, so we have to do it ourselves.
        # Yay for file special-cases (fileobject.c, PyFile_WriteObject).
        # If somebody wants to write some other object to here, they do it
        # at their own peril.
        if isinstance(stuff, unicode):
            stuff = stuff.encode('utf-8')
        self.remainder = self.remainder + stuff

        # if there's less than 128 bytes, buffer
        if len(self.remainder) < 128:
            return

        # if there's lots, then send it in 1/2K blocks
        while len(self.remainder) > 512:
            # We send things as Unicode inside JSON, so we must only send
            # complete UTF-8 characters.
            (blk, count) = self._trim_incomplete_final(self.remainder[:512])
            self.cmdQ.put({"output":blk.decode('utf-8', 'replace')})
            expiry.ping()
            ln = self.lineQ.get()
            self.remainder = self.remainder[512 - count:]

        # Finally, split the remainder up into lines, and ship all the
        # completed lines off to the server.
        lines = self.remainder.split("\n")
        self.remainder = lines[-1]
        del lines[-1]

        if len(lines) > 0:
            lines.append('')
            text = "\n".join(lines)
            self.cmdQ.put({"output":text.decode('utf-8', 'replace')})
            expiry.ping()
            ln = self.lineQ.get()
            if 'interrupt' in ln:
                raise Interrupt()

    def flush(self):
        if len(self.remainder) > 0:
            (out, count) = self._trim_incomplete_final(self.remainder)
            self.cmdQ.put({"output":out.decode('utf-8', 'replace')})
            expiry.ping()
            ln = self.lineQ.get()
            # Leave incomplete characters in the buffer.
            # Yes, this does mean that an incomplete character will be left
            # off the end, but we discussed this and it was deemed best.
            self.remainder = self.remainder[len(self.remainder)-count:]
            if 'interrupt' in ln:
                raise Interrupt()

class WebIO(object):
    """Provides a file like interface to the Web front end of the console.
    You may print text to the console using write(), flush any buffered output 
    using flush(), or request text from the console using readline()"""
    
    def __init__(self, cmdQ, lineQ):
        self.cmdQ = cmdQ
        self.lineQ = lineQ
        self.stdin = StdinFromWeb(self.cmdQ, self.lineQ)
        self.stdout = StdoutToWeb(self.cmdQ, self.lineQ)

    def write(self, stuff):
        self.stdout.write(stuff)

    def flush(self):
        self.stdout.flush()

    def readline(self):
        self.stdout.flush()
        return self.stdin.readline()

class PythonRunner(Thread):
    def __init__(self, cmdQ, lineQ):
        self.cmdQ = cmdQ
        self.lineQ = lineQ
        self.webio = WebIO(self.cmdQ, self.lineQ)
        Thread.__init__(self)

    def execCmd(self, cmd):
        try:
            sys.stdin = self.webio
            sys.stdout = self.webio
            sys.stderr = self.webio
            # We don't expect a return value - 'single' symbol prints it.
            self.eval(cmd)
            self.webio.flush()
            self.cmdQ.put({"okay": None})
            self.curr_cmd = ''
        except:
            tb = format_exc_start(start=1)
            self.webio.flush()
            self.cmdQ.put({"exc": ''.join(tb).decode('utf-8', 'replace')})
            self.curr_cmd = ''

    def run(self):
        self.globs = {}
        self.globs['__builtins__'] = globals()['__builtins__']
        self.curr_cmd = ''

        while True:
            ln = self.lineQ.get()
            if 'chat' in ln:
                if self.curr_cmd == '':
                    self.curr_cmd = ln['chat']
                else:
                    self.curr_cmd = self.curr_cmd + '\n' + ln['chat']
                try:
                    cmd = codeop.compile_command(self.curr_cmd, '<web session>')
                    if cmd is None:
                        # The command was incomplete,
                        # so send back a None, so the
                        # client can print a '...'
                        self.cmdQ.put({"more":None})
                    else:
                        self.execCmd(cmd)
                except:
                    tb = format_exc_start(start=3)
                    self.cmdQ.put({"exc": ''.join(tb).decode('utf-8', 'replace')})
                    self.webio.flush()
                    self.curr_cmd = ''
            elif 'block' in ln:
                # throw away a partial command.
                try:
                    cmd = compile(ln['block'], "<web session>", 'exec');
                    self.execCmd(cmd)
                except:
                    tb = format_exc_start(start=1)
                    self.webio.flush()
                    self.cmdQ.put({"exc": ''.join(tb).decode('utf-8', 'replace')})
                    self.curr_cmd = ''
            elif 'flush' in ln:
                # reset the globals
                self.globs = {}
                self.globs['__builtins__'] = globals()['__builtins__']
                self.cmdQ.put({'response': 'okay'})
                # Unpickle the new space (if provided)
                if isinstance(ln['flush'],dict):
                    for g in ln['flush']:
                        try:
                            self.globs[g] = cPickle.loads(ln['flush'][g])
                        except:
                            pass
            elif 'call' in ln:
                call = {}
                stdout = cStringIO.StringIO()
                stderr = cStringIO.StringIO()
                sys.stdout = stdout
                sys.stderr = stderr

                if isinstance(ln['call'], dict):
                    params = ln['call']
                    try:
                        # Expand parameters
                        if isinstance(params['args'], list):
                            args = map(self.eval, params['args'])
                        else:
                            args = []
                        if isinstance(params['kwargs'], dict):
                            kwargs = {}
                            for kwarg in params['kwargs']:
                                kwargs[kwarg] = self.eval(
                                    params['kwargs'][kwarg])
                        else:
                            kwargs = {}

                        # Run the fuction
                        function = self.eval(params['function'])
                        try:
                            call['result'] = function(*args, **kwargs)
                        except Exception, e:
                            exception = {}
                            tb = format_exc_start(start=1)
                            exception['traceback'] = \
                                ''.join(tb).decode('utf-8', 'replace')
                            exception['except'] = cPickle.dumps(e,
                                PICKLEVERSION)
                            call['exception'] = exception
                    except Exception, e:
                        tb = format_exc_start(start=1)
                        self.cmdQ.put(
                            {"exc": ''.join(tb).decode('utf-8', 'replace')})
                    
                    # Write out the inspection object
                    call['stdout'] = stdout.getvalue()
                    call['stderr'] = stderr.getvalue()
                    self.cmdQ.put(call)
                else:
                    self.cmdQ.put({'response': 'failure'})
                stdout.close()
                stderr.close()
                self.curr_cmd = ''
            elif 'inspect' in ln:
                # Like block but return a serialization of the state
                # throw away partial command
                inspection = {}
                stdout = cStringIO.StringIO()
                stderr = cStringIO.StringIO()
                try:
                    cmd = compile(ln['inspect'], "<web session>", 'exec');
                    sys.stdin = None
                    sys.stdout = stdout
                    sys.stderr = stderr
                    # We don't expect a return value - 'single' symbol prints 
                    # it.
                    self.eval(cmd)
                except Exception, e:
                    exception = {}
                    tb = format_exc_start(start=1)
                    exception['traceback'] = \
                        ''.join(tb).decode('utf-8', 'replace')
                    exception['except'] = cPickle.dumps(e, PICKLEVERSION)
                    inspection['exception'] = exception                
                
                # Write out the inspection object
                inspection['stdout'] = stdout.getvalue()
                inspection['stderr'] = stderr.getvalue()
                inspection['globals'] = flatten(self.globs)
                self.cmdQ.put(inspection)
                stdout.close()
                stderr.close()
                self.curr_cmd = ''
            elif 'set_vars' in ln:
                # Adds some variables to the global dictionary
                for var in ln['set_vars']:
                    try:
                        self.globs[var] = self.eval(ln['set_vars'][var])
                    except Exception, e:
                        tb = format_exc_start(start=1)
                        self.cmdQ.put(
                            {"exc": ''.join(tb).decode('utf-8', 'replace')})

                self.cmdQ.put({'response': 'okay'})
            else:
                raise Exception, "Invalid Command"

    def eval(self, source):
        """ Evaluates a string in the private global space """
        return eval(source, self.globs)

def daemonize():
    if os.fork():   # launch child and...
        os._exit(0) # kill off parent
    os.setsid()
    if os.fork():   # launch child and...
        os._exit(0) # kill off parent again.
    os.umask(077)

# The global 'magic' is the secret that the client and server share
# which is used to create and md5 digest to authenticate requests.
# It is assigned a real value at startup.
magic = ''

cmdQ = Queue.Queue()
lineQ = Queue.Queue()
interpThread = PythonRunner(cmdQ, lineQ)
terminate = None

# Default expiry time of 15 minutes
expiry = ExpiryTimer(15 * 60)

def initializer():
    interpThread.setDaemon(True)
    interpThread.start()
    signal.signal(signal.SIGXCPU, sig_handler)
    expiry.ping()

def sig_handler(signum, frame):
    """Handles response from signals"""
    global terminate
    if signum == signal.SIGXCPU:
        terminate = "CPU Time Limit Exceeded"

def dispatch_msg(msg):
    global terminate
    if msg['cmd'] == 'restart':
        terminate = "User requested console be reset"
    if terminate:
        raise common.chat.Terminate({"restart":terminate})
    expiry.ping()
    lineQ.put({msg['cmd']:msg['text']})
    if terminate:
        raise common.chat.Terminate({"restart":terminate})
    return cmdQ.get()

def format_exc_start(start=0):
    etype, value, tb = sys.exc_info()
    tbbits = traceback.extract_tb(tb)[start:]
    list = ['Traceback (most recent call last):\n']
    list = list + traceback.format_list(tbbits)
    list = list + traceback.format_exception_only(etype, value)
    return ''.join(list)

def incomplete_utf8_sequence(byteseq):
    """
    str -> int
    Given a UTF-8-encoded byte sequence (str), returns the number of bytes at
    the end of the string which comprise an incomplete UTF-8 character
    sequence.

    If the string is empty or ends with a complete character OR INVALID
    sequence, returns 0.
    Otherwise, returns 1-3 indicating the number of bytes in the final
    incomplete (but valid) character sequence.

    Does not check any bytes before the final sequence for correctness.

    >>> incomplete_utf8_sequence("")
    0
    >>> incomplete_utf8_sequence("xy")
    0
    >>> incomplete_utf8_sequence("xy\xc3\xbc")
    0
    >>> incomplete_utf8_sequence("\xc3")
    1
    >>> incomplete_utf8_sequence("\xbc\xc3")
    1
    >>> incomplete_utf8_sequence("xy\xbc\xc3")
    1
    >>> incomplete_utf8_sequence("xy\xe0\xa0")
    2
    >>> incomplete_utf8_sequence("xy\xf4")
    1
    >>> incomplete_utf8_sequence("xy\xf4\x8f")
    2
    >>> incomplete_utf8_sequence("xy\xf4\x8f\xa0")
    3
    """
    count = 0
    expect = None
    for b in byteseq[::-1]:
        b = ord(b)
        count += 1
        if b & 0x80 == 0x0:
            # 0xxxxxxx (single-byte character)
            expect = 1
            break
        elif b & 0xc0 == 0x80:
            # 10xxxxxx (subsequent byte)
            pass
        elif b & 0xe0 == 0xc0:
            # 110xxxxx (start of 2-byte sequence)
            expect = 2
            break
        elif b & 0xf0 == 0xe0:
            # 1110xxxx (start of 3-byte sequence)
            expect = 3
            break
        elif b & 0xf8 == 0xf0:
            # 11110xxx (start of 4-byte sequence)
            expect = 4
            break
        else:
            # Invalid byte
            return 0

        if count >= 4:
            # Seen too many "subsequent bytes", invalid
            return 0

    if expect is None:
        # We never saw a "first byte", invalid
        return 0

    # We now know expect and count
    if count >= expect:
        # Complete, or we saw an invalid sequence
        return 0
    elif count < expect:
        # Incomplete
        return count

# Takes an object and returns a flattened version suitable for JSON
def flatten(object):
    flat = {}
    for o in object:
        try:
            flat[o] = cPickle.dumps(object[o], PICKLEVERSION)
        except TypeError:
            try:
                o_type = type(object[o]).__name__
                o_name = object[o].__name__
                fake_o = common.util.FakeObject(o_type, o_name)
                flat[o] = cPickle.dumps(fake_o, PICKLEVERSION)
            except AttributeError:
                pass
    return flat

if __name__ == "__main__":
    port = int(sys.argv[1])
    magic = sys.argv[2]
    
    # Sanitise the Enviroment
    os.environ = {}
    os.environ['PATH'] = '/usr/local/bin:/usr/bin:/bin'

    if len(sys.argv) >= 4:
        # working_dir
        os.chdir(sys.argv[3])
        os.environ['HOME'] = sys.argv[3]

    # Make python's search path follow the cwd
    sys.path[0] = ''

    common.chat.start_server(port, magic, True, dispatch_msg, initializer)
