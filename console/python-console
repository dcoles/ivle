#!/usr/bin/python

# usage:
#   python-console <port> <magic>

import sys
import web
import md5
import codeop
import cjson
import cgi
import cStringIO
import signal
import Queue
from threading import Thread

class StdinFromWeb(object):
    def __init__(self, cmdQ, lineQ):
        self.cmdQ = cmdQ
        self.lineQ = lineQ

    def readline(self):
        # stop the clock!
        signal.alarm(0)
        self.cmdQ.put({"input":None})
        ln = self.lineQ.get()
        if 'chat' in ln:
            # restart the clock:
            # Some of our 5 seconds may have elapsed, but never mind.
            signal.alarm(5)
            return ln['chat']

class PythonRunner(Thread):
    def __init__(self, cmdQ, lineQ):
        self.cmdQ = cmdQ
        self.lineQ = lineQ
        self.out = cStringIO.StringIO()
        Thread.__init__(self)

    def run(self):
        self.init_state()
        compiler = codeop.CommandCompiler()

        while True:
            ln = self.lineQ.get()
            if 'chat' in ln:
                if self.curr_cmd == '':
                    self.curr_cmd = ln['chat']
                else:
                    self.curr_cmd = self.curr_cmd + '\n' + ln['chat']
                try:
                    cmd = compiler(self.curr_cmd)
                    if cmd is None:
                        # The command was incomplete,
                        # so send back a None, so the
                        # client can print a '...'
                        self.cmdQ.put({"more":None})
                    else:
                        # The command was complete,
                        # so evaluate it!
                        sys.stdin = StdinFromWeb(self.cmdQ, self.lineQ)
                        self.out = cStringIO.StringIO()
                        sys.stdout = self.out
                        sys.stderr = self.out
                        signal.alarm(5)
                        res = eval(cmd, self.globs, self.locls)
                        signal.alarm(0)
                        self.cmdQ.put({"okay":(self.out.getvalue(),res)})
                        self.curr_cmd = ''
                except Exception, exc:
                    signal.alarm(0)
                    self.cmdQ.put({"exc":(self.out.getvalue(),str(exc))})
                    self.curr_cmd = ''
            if 'block' in ln:
                # throw away a partial command.
                self.curr_cmd = ''
                try:
                    cmd = compile(ln['block'], "<web session>", 'exec');
                    
                    sys.stdin = StdinFromWeb(self.cmdQ, self.lineQ)
                    self.out = cStringIO.StringIO()
                    sys.stdout = out
                    sys.stderr = out
                    signal.alarm(5)
                    res = eval(cmd, self.globs, self.locls)
                    signal.alarm(0)
                    self.cmdQ.put({"okay":(self.out.getvalue(),res)})
                    self.curr_cmd = ''
                except Exception, exc:
                    signal.alarm(0)
                    self.cmdQ.put({"exc":(self.out.getvalue(),str(exc))})

    def init_state(self):
        self.globs = {}
        self.globs['__builtins__'] = globals()['__builtins__']
        self.locls = {}
        self.curr_cmd = ''

urls = (
    '/chat',        'chat',
    '/block',       'block')

# The global 'magic' is the secret that the client and server share
# which is used to create and md5 digest to authenticate requests.
# It is assigned a real value at startup.
magic = ''

class chat:

    def POST(self):
        inp = web.input()

        # Authenticate
        digest = md5.new(inp.text + magic).digest().encode('hex')
        if inp.digest != digest:
            web.output("401 Unauthorized")
            web.ctx.status = '401 Unauthorized'
            return

        # Okay, so the authentication succeeded,
        # so now we have the trivial matter of actually
        # executing the python....
        lineQ.put({'chat':inp.text})
        r = cmdQ.get()
        sys.__stderr__.write(cjson.encode(r) + "\n")
        web.output(cjson.encode(r))

class block:

    def POST(self):
        inp = web.input()

        # Authenticate
        digest = md5.new(inp.text + magic).digest().encode('hex')
        if inp.digest != digest:
            web.output("401 Unauthorized")
            web.ctx.status = '401 Unauthorized'
            return

        # Okay, so the authentication succeeded,
        # so now we have the trivial matter of actually
        # executing the python....
        lineQ.put({'block':inp.text})
        r = cmdQ.get()
        sys.__stderr__.write(cjson.encode(r) + "\n")
        web.output(cjson.encode(r))

cmdQ = Queue.Queue()
lineQ = Queue.Queue()
interpThread = PythonRunner(cmdQ, lineQ)

if __name__ == "__main__":
    magic = sys.argv[2]
    interpThread.setDaemon(True)
    interpThread.start()
    web.run(urls, globals())
