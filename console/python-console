#!/usr/bin/python

# usage:
#   python-console <port> <magic>

import cjson
import codeop
import cStringIO
import md5
import os
import Queue
import signal
import socket
import sys
from threading import Thread

class StdinFromWeb(object):
    def __init__(self, cmdQ, lineQ):
        self.cmdQ = cmdQ
        self.lineQ = lineQ

    def readline(self):
        # stop the clock!
        signal.alarm(0)
        self.cmdQ.put({"input":None})
        ln = self.lineQ.get()
        if 'chat' in ln:
            # restart the clock:
            # Some of our 5 seconds may have elapsed, but never mind.
            signal.alarm(5)
            return ln['chat']

class PythonRunner(Thread):
    def __init__(self, cmdQ, lineQ):
        self.cmdQ = cmdQ
        self.lineQ = lineQ
        self.out = cStringIO.StringIO()
        Thread.__init__(self)

    def run(self):
        self.init_state()
        compiler = codeop.CommandCompiler()

        while True:
            ln = self.lineQ.get()
            if 'chat' in ln:
                if self.curr_cmd == '':
                    self.curr_cmd = ln['chat']
                else:
                    self.curr_cmd = self.curr_cmd + '\n' + ln['chat']
                try:
                    cmd = compiler(self.curr_cmd)
                    if cmd is None:
                        # The command was incomplete,
                        # so send back a None, so the
                        # client can print a '...'
                        self.cmdQ.put({"more":None})
                    else:
                        # The command was complete,
                        # so evaluate it!
                        sys.stdin = StdinFromWeb(self.cmdQ, self.lineQ)
                        sys.stdout = self.out
                        sys.stderr = self.out
                        signal.alarm(5)
                        res = eval(cmd, self.globs, self.locls)
                        signal.alarm(0)
                        self.cmdQ.put({"okay":(self.out.getvalue(),res)})
                        self.curr_cmd = ''
                        self.out = cStringIO.StringIO()
                except Exception, exc:
                    signal.alarm(0)
                    self.cmdQ.put({"exc":(self.out.getvalue(),str(exc))})
                    self.curr_cmd = ''
                    self.out = cStringIO.StringIO()
            if 'block' in ln:
                # throw away a partial command.
                try:
                    cmd = compile(ln['block'], "<web session>", 'exec');
                    
                    sys.stdin = StdinFromWeb(self.cmdQ, self.lineQ)
                    self.out = cStringIO.StringIO()
                    sys.stdout = self.out
                    sys.stderr = self.out
                    signal.alarm(5)
                    res = eval(cmd, self.globs, self.locls)
                    signal.alarm(0)
                    self.cmdQ.put({"okay":(self.out.getvalue(),res)})
                    self.curr_cmd = ''
                    self.out = cStringIO.StringIO()
                except Exception, exc:
                    signal.alarm(0)
                    self.cmdQ.put({"exc":(self.out.getvalue(),str(exc))})
                    self.curr_cmd = ''
                    self.out = cStringIO.StringIO()

    def init_state(self):
        self.globs = {}
        self.globs['__builtins__'] = globals()['__builtins__']
        self.locls = {}
        self.curr_cmd = ''

def daemonize():
    if os.fork():   # launch child and...
        os._exit(0) # kill off parent
    os.setsid()
    if os.fork():   # launch child and...
        os._exit(0) # kill off parent again.
    os.umask(077)

# The global 'magic' is the secret that the client and server share
# which is used to create and md5 digest to authenticate requests.
# It is assigned a real value at startup.
magic = ''

cmdQ = Queue.Queue()
lineQ = Queue.Queue()
interpThread = PythonRunner(cmdQ, lineQ)

if __name__ == "__main__":
    port = int(sys.argv[1])
    magic = sys.argv[2]

    # Attempt to open the socket.
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.bind(('', port))
    s.listen(1)

    # Excellent! It worked. Let's turn ourself into a daemon,
    # then get on with the job of being a python interpreter.
    daemonize()

    interpThread.setDaemon(True)
    interpThread.start()

    while True:
        (conn, addr) = s.accept()
        try:
            # Grab the input
            buf = cStringIO.StringIO()
            blk = conn.recv(1024)
            while blk:
                buf.write(blk)
                try:
                    blk = conn.recv(1024, socket.MSG_DONTWAIT)
                except:
                    # Exception thrown if it WOULD block (but we
                    # told it not to wait) - ie. we are done
                    blk = None
            inp = buf.getvalue()
            msg = cjson.decode(inp)
            
            # Check that the message is 
            digest = md5.new(msg['text'] + magic).digest().encode('hex')
            if msg['digest'] != digest:
                conn.close()
                continue

            lineQ.put({msg['cmd']:msg['text']})
            r = cmdQ.get()
            conn.sendall(cjson.encode(r))
            conn.close()
        except Exception, e:
            conn.close()
