#!/usr/bin/python

# Notes
# -----
#
# 1. execute in a chroot jail
# 2. enforce resource limits
# 3. allow multiple connections
# 4. enforce some kind of auth.
#
# Another thing is to examine the commonality and difference between
# the console app and the python evaluator in the tutorial system.

import socket
import cStringIO
import codeop
import sys
import cjson
import signal

def recv_lines(sok):
    buf = ''
    s = sok.recv(4096)
    while len(s) > 0:
        buf = buf + s
        i = buf.find('\r\n')
        while i != -1:
            l = buf[0:i]
            yield l
            buf = buf[i+1:]
            i = buf.find('\r\n')
        s = sok.recv(4096)

def timeout(signum, frame):
    print 'signal: ', signum
    raise Exception, 'Timeout!'

# signal.signal(signal.SIGALRM, timeout)
# 
# sok = socket.socket(socket.AF_INET)
# sok.bind(('localhost',9998))
# sok.listen(1)
# (new_sok,addr) = sok.accept()
# 
# c = codeop.CommandCompiler()
# 
# globs = {}
# locos = {}
# globs['__builtins__'] = globals()['__builtins__']
# 
# out = cStringIO.StringIO()
# sys.stdout = out
# first = True
# for line in req_lines(new_sok):
#     if first:
#         src = line
#         first = False
#     else:
#         src = src + '\n' + line
#     cmd = c(src)
#     if cmd is not None:
#         signal.alarm(5)
#         res = eval(cmd, globs, locos)
#         signal.alarm(0)
#         new_sok.send(cjson.encode((out.getvalue(),res)) + '\n')
#         out = cStringIO.StringIO()
#         sys.stdout = out
#         first = True
# 
# sok.shutdown(socket.SHUT_RDWR)

if __name__ == "__main__":
    try:
        uid = int(sys.argv[1])
    except ValueError, v:
        print >> sys.stderr, "uid must be an integer."
        sys.exit(1)
    jail = sys.argv[2]
    cwd = sys.argv[3]
    try:
        port = int(sys.argv[4])
    except ValueError, v:
        print >> sys.stderr, "port must be an integer."
        sys.exit(1)
    magic = sys.argv[5]
    # magic = raw_input()

    try:
        pid = os.fork()
        if pid > 0:
            sys.exit(0)
    except OSError, e:
        print >> sys.stderr, "fork #1 failed: %d (%s)" % (e.errno, e.strerror)
        sys.exit(1)

    # Okay, now decouple from the parent environment
    os.chdir('/')
    os.setsid()
    os.umask(0)

    # do second fork
    try:
        pid = os.fork()
        if pid > 0:
            sys.exit(0)
    except OSError, e:
        print >> sys.stderr, "fork #2 failed: %d (%s)" % (e.errno, e.strerror)
        sys.exit(1)

    # establish the chrooted environment
    setup_environment(uid, jail, cwd)

    signal.signal(signal.SIGALRM, timeout)

    main_sok = socket.socket(socket.AF_INET)
    main_sok.bind(('localhost',port))
    main_sok.listen(1)

    comp = codeop.CommandCompiler()
    globs = {}
    locos = {}
    globs['__builtins__'] = globals()['__builtins__']

    global keep_going
    keep_going = True
    while keep_going:
        (sok,addr) = main_sok.accept()
        # do checks on addr

        try:
            first = True
            for line in req_lines(new_sok):
                if first:
                    src = line
                    first = False
                else:
                    src = src + '\n' + line
                try:
                    cmd = comp(src)
                    if cmd is not None:
                        signal.alarm(5)
                        res = eval(cmd, globs, locos)
                        signal.alarm(0)
                        rval = (out.getvalue(), res, None)
                        sok.send(cjson.encode(rval) + '\n')
                        out = cStringIO.StringIO()
                        sys.stdout = out
                        first = True
                except Exception, e:
                        rval = (None, None, str(e))
                        sok.send(cjson.encode(rval) + '\n')
                        out = cStringIO.StringIO()
                        sys.stdout = out
                        first = True
        finally:
            sok.close()


    main_sok.shutdown(socket.SHUT_RDWR)
